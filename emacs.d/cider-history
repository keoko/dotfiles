;; -*- coding: utf-8-unix -*-
;; Automatically written history of CIDER REPL session
;; Edit at your own risk

("(stop)" "(reset)" " " "(reset)" " " "(reset)" "(deref ds/data-store)" "(require '[sisyphus.component.data-store :as ds])" "(reset)" "(deref ds/data-store)" "(require '[sisyphus.component.data-store :as ds])" "(deref ds/data-store)" "(require '[sisyphus.component.data-store :as ds])" "(reset)" "(require '[sisyphus.component.data-store :as ds])" "(reset)" "(doc get-in)" "(deref ds/data-store)" "(require '[sisyphus.component.data-store :as ds])" "(reset)" "(deref ds/data-store)" "(require '[sisyphus.component.data-store :as ds])" "(reset)" "(keyword \"stg\")" "(stop)" "(reset)" "(r/get-repo-hash repo)" "(require '[sisyphus.repository :as r])" "(.getName (.resolve (.getRepository repo) \"HEAD^{tree}\"))" "(.toString (.resolve (.getRepository repo) \"HEAD^{tree}\"))" "(.toObjectId (.resolve (.getRepository repo) \"HEAD^{tree}\"))" "(.resolve (.getRepository repo) \"HEAD^{tree}\")" "(.getRepository repo)" "(type repo)" "(.resolve repo \"HEAD^{tree}\")" "(resolve repo \"HEAD^{tree}\")" "(git/branch-list-with-heads repo)" "(git/commit-info repo \"HEAD^{tree}\")" "(git/commit-info repo)" "repo" "(def repo (clj-jgit.porcelain/load-repo \"/tmp/app1-prd\"))" "(require '[clj-jgit.querying :as git])" "(stop)" "()" "(require '[clj-jgit.querying :as git])" "(reset)" "jj" "(go)" "(stop)" "(go)" "(stop)" "(go)" "(.toUperCase \"acdfds\")" "(.toUpperCase \"acdfds\")" "(snag-quotes \"quotes\" 2)" "(slurp \"http://www.braveclojure.com/random-quote\")" "(defn append-to-file
  \"Write a string to the end of a file\"
  [filename s]
  (spit filename s :append true))

(defn format-quote
  \"Delineate the beginning and end of a quote because it's convenient\"
  [quote]
  (str \"=== BEGIN QUOTE ===\\n\" quote \"=== END QUOTE ===\\n\\n\"))

(defn random-quote
  \"Retrieve a random quote and format it\"
  []
  (format-quote (slurp \"http://www.braveclojure.com/random-quote\")))

(defn snag-quotes
  [filename num-quotes]
  (let [c (chan)]
    (go (while true (append-to-file filename (<! c))))
    (dotimes [n num-quotes] (go (>! c (random-quote))))))
" "(snag-quotes \"quotes\" 2)" "(defn append-to-file
  \"Write a string to the end of a file\"
  [filename s]
  (spit filename s :append true))

(defn format-quote
  \"Delineate the beginning and end of a quote because it's convenient\"
  [quote]
  (str \"=== BEGIN QUOTE ===\\n\" quote \"=== END QUOTE ===\\n\\n\"))

(defn random-quote
  \"Retrieve a random quote and format it\"
  []
  (format-quote (slurp \"http://www.braveclojure.com/random-quote\")))

(defn snag-quotes
  [filename num-quotes]
  (let [c (chan)]
    (go (while true (append-to-file filename (<! c))))
    (dotimes [n num-quotes] (go (>! c (random-quote))))))
" "(let [c1 (chan)
      c2 (chan)]
  (go (<! c2))
   (let [[value channel] (alts!! [c1 [c2 \"put!\"]])]
    (println value)
    (= channel c2)))" "(let [c1 (chan)]
  (upload \"serious.jpg\" c1)
  (let [[headshot channel] (alts!! [c1 (timeout 20)])]
    (if headshot
      (println \"Sending headshot notification for\" headshot)
      (println \"Timed out!\"))))" "(let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (upload \"serious.jpg\" c1)
  (upload \"fun.jpg\" c2)
  (upload \"sassy.jpg\" c3)
   (let [[headshot channel] (alts!! [c1 c2 c3])]
    (println \"Sending headshot notification for\" headshot)))" "(defn upload
  [headshot c]
  (go (Thread/sleep (rand 100))
      (>! c headshot)))" "(let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (go (>! c2 (clojure.string/upper-case (<! c1))))
  (go (println (<! c2)))
  (>!! c1 \"redrum\"))" "(let [c1 (chan)
      c2 (chan)
      c3 (chan)]
  (go (>! c2 (clojure.string/upper-case (<! c1))))
  (go (>! c3 (clojure.string/reverse (<! c2))))
  (go (println (<! c3)))
  (>!! c1 \"redrum\"))" "(let [[in out] (hot-dog-machine-v2 2)]
  (>!! in \"pocket lint\")
  (println (<!! out))

    (>!! in 3)
  (println (<!! out))

  (>!! in 3)
  (println (<!! out))

  (>!! in 3)
  (<!! out))" "(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (> hc 0)
            (let [input (<! in)]
             (if (= 3 input)
                (do (>! out \"hot dog\")
                    (recur (dec hc)))
                (do (>! out \"wilted lettuce\")
                    (recur hc))))
           (do (close! in)
                (close! out)))))
    [in out]))
" "(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (> hc 0)
            (let [input (<! in)]
             ➊(if (= 3 input)
                (do (>! out \"hot dog\")
                    (recur (dec hc)))
                (do (>! out \"wilted lettuce\")
                    (recur hc))))
           ➋(do (close! in)
                (close! out)))))
    [in out]))
" "(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (> hc 0)
            (let [input (<! in)]
             ➊(if (= 3 input)
                (do (>! out \"hot dog\")
                    (recur (dec hc)))
                (do (>! out \"wilted lettuce\")
                    (recur hc))))
           ➋(do (close! in)
                (close! out)))))
    [in out]))
(defn hot-dog-machine-v2
  [hot-dog-count]
  (let [in (chan)
        out (chan)]
    (go (loop [hc hot-dog-count]
          (if (> hc 0)
            (let [input (<! in)]
             ➊(if (= 3 input)
                (do (>! out \"hot dog\")
                    (recur (dec hc)))
                (do (>! out \"wilted lettuce\")
                    (recur hc))))
           ➋(do (close! in)
                (close! out)))))
    [in out]))
" "(let [[in out] (hot-dog-machine)]
  (>!! in \"pocket lint\")
  (<!! out))" "(defn hot-dog-machine
  []
  (let [in (chan)
        out (chan)]
    (go (<! in)
        (>! out \"hot dog\"))
    [in out]))
" "dd" "(>!! echo-buffer \"ketchup\")" "(def echo-buffer (chan 2))" "(pr \"jl\")" "(go (println (<! echo-chan)))" "(>!! echo-chan \"ketchup it's it\")" "(>!! echo-chan \"ketchup\")" "(go (println (<! echo-chan)))" "(def echo-chan (chan))" "(go)" "(when-let)" "(dissoc {} :b)" "(go)" "(reset)" "(go)" "(stop)" "(reset)" "(go)" "(reeset)" "(map #(.getName %) (ds/read-directory f))" "(ds/read-directory f)" "(.isDirectory f)" "(.getCanonicalPath f)" "(.getName f)" "f" "(def f (clojure.java.io/file \"/tmp/app1-prd\"))" "(clojure.java.io/file \"/tmp/app1-prd\")" "(ds/read-directory (clojure.java.io/file \"/tmp/app1-prd\"))" "(require '[sisyphus.data-store :as ds])" "(go)" " (go)" " (stop)" "(reset)" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo] :reload-all)" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo] :reload-all)" "(git/git-branch-list r)" "(git/git-fetch-all r)" "(git/git-branch-list r)" "(git/git-checkout r \"stg\")" "r" "(def r (git/load-repo \"/tmp/app1-stg\"))" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo] :reload-all)" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo] :reload-all)" "(git/git-clone-full \"http://git@192.168.99.100:10080/root/app2.git\" \"/tmp/app1-test\")" "(git/git-clone-full \"http://git@192.168.99.100:10080/root/app1-config.git\" \"/tmp/app1-test\")" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo] :reload-all)" "(repo/update-repos \"1\")" "repo/repos" "(require '[sisyphus.repository :as repo] :reload-all)" "(repo/update-repos \"1\")" "repo/repos" "(require '[sisyphus.repository :as repo] :reload-all)" "repo/repos" "(repo/update-repos \"1\")" "(require '[clj-jgit.porcelain :as git] :reload-all)" "(repo/update-repos \"1\")" "(require '[clj-jgit.porcelain :as git] :reload-all)" "r" "(git/git-checkout r \"stg\")" "(git/git-fetch-all r)" "(git/git-checkout r \"stg\")" "r" "(def r (git/load-repo \"app1-stg\"))" "(require '[clj-jgit.porcelain :as git])" "(require '[clj-jgit.porcelaine :as git])" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo] :reload-all)" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo] :reload-all)" "(repo/update-repos \"1\")" "repo/repos" "(require '[sisyphus.repository :as repo] :reload-all)" "(require '[sisyphus.repository :as repo] :reload)" "repo/repos" "(require '[sisyphus.repository :as repo])" "repo/repos" "(repo/repos)" "(repo/update-repos \"1\")" "(repo/update-repos)" "(repo/update-repos \"1\")" "(repo/test1)" "(repo/update-repo)" "(repo/update-repos \"1\")" "repo/repos" "(repo/repos)" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo])" "(repo/update-repos \"1\")" "(require '[sisyphus.repository :as repo])" "(go)" "(get {:a 1 :b 2} :a)" "(stop)" "(go)" "(stop)" "(reset)" "(go)" "(stop)" "(reset)" "(yaml/parse-string \"[ New York Yankees, Atlanta Braves ]\")" "(yaml/parse-string \"? [ New York Yankees, Atlanta Braves ]\")" "(yaml/parse-string \"? [ New York Yankees,
    Atlanta Braves ]\")" "(pprint (yaml/parse-string f))" "(yaml/parse-string f)" "(def f (slurp \"resources/log_file.yaml\"))" "(yaml/parse-string f)" "(def f (slurp \"resources/log_file.yaml\"))" "(yaml/parse-string f)" "(def f (slurp \"resources/log_file.yaml\"))" "(yaml/parse-string f)" "(def f (slurp \"resources/log_file.yaml\"))" "(yaml/parse-string f)" "f" "(def f (slurp \"resources/log_file.yaml\"))" "(type f)" "(yaml/parse-string f)" "f" "(def f (slurp \"resources/log_file.yaml\"))" "(yaml/parse-string \"#- test 12, - test 14 - asds\")" "(yaml/parse-string \"#- test 12, - test 14 \\- asds\")" "(yaml/parse-string \"#- test 12, - test 14\")" "(yaml/parse-string \"- test 12, - test 14\")" "(yaml/parse-string \"- test 12\")" "(yaml/parse-string \"foo: test\")" "(require '[clj-yaml.core :as yaml])" "(reset)" "(go)" "(reset)" "(ds/show-timbre)" "(require '[sisyphus.data-store :as ds])" "timbre/*config*" "(reset)" "(ds/test-log)" "(require '[sisyphus.data-store :as ds])" "(timbre/debug \"hola\")" "(timbre/trace \"test\")" "timbre/*config*" "(timbre/*config*)" "(require '[taoensso.timbre :as timbre])" "(require [taoensso.timbre :as timbre])" "(go)" "(timbre/set-config! [:appenders :spit :enabled?])" "timbre/*config*" "(timbre/set-config! [:appenders :spit :enabled?])" "(timbre/set-config! [:appenders :spit :enabled?] true)" "(timbre/set-config! [:appenders :spit :enabled?] true)
(timbre/set-config! [:shared-appender-config :spit-filename] \"/path/my-file.log\")" "timbre/*config*" "(timbre/*config*)" "@timbre/config" "(require '[taoensso.timbre :as timbre])" "(require '[com.postspectacular.rotor :as rotor])" "(reset)" "(go)" "(reset)" "(go)" "(info \"this is a test\")" "(require '[taoensso.timbre :refer (info)])" "(reset)" "(go)" "(reset)" "(go)" "(git/git-pull repo)" "(git/git-fetch-all repo)" "(git/git-pull repo)" "repo" "(def repo (git/load-repo d))" "(require '[clj-jgit.porcelain :as git])" "(require '[clj-jgit.procelain :as git])" "(def repo (git/load-repo d))" "d" "(def d (ds/get-env-dir! :stg))" "d" "(def d (ds/get-env-dir! :prd))" "(require '[sisyphus.data-store :as ds])" "(reset)" "(git/git-branch-list repo)" "(git/git-fetch-all repo)" "(git/git-push)" "(git/git-branch-create repo \"dev\")" "(git/git-branch-current repo)" "(git/git-branch-current)" "(git/git-branch-list repo)" "(git/git-checkout repo \"refs/heads/master\")" "(git/git-checkout repo \"master\")" "(git/git-checkout repo \"stg\")" "(git/git-checkout repo \"master1\")" "(git/git-checkout repo \"master\")" "(git/git-branch-list repo)" "(git/git-pull repo)" "(git/git-branch-list repo)" "repo" "(def repo (git/load-repo d))" "d" "(def d (ds/get-env-dir! :prd))" "(def repo (git/load-repo d))" "(require '[clj-jgit.porcelain :as git])" "(require '[clj-jgit :as git])" "d" "f" "(def d (ds/get-env-dir! \"prd\"))" "(def d (da/get-env-dir! \"prd\"))" "(require '[sisyphus.data-store :as ds])" "(reset)" "(doc clj-jgit.porcelain/git-checkout)" "(reset)" "(ds/load-data \"\" :prd)" "(ds/load-data \"A\" :prd)" "(ds/load-data \"\" :prd)" "(ds/read-directories [] f)" "(ds/read-directory f)" "(ds/read-directories [] f)" "(ds/read-directories [\"A\"] f)" "(ds/read-directories [] f)" "(ds/read-directory f)" "(ds/read-directories [] f)" "(ds/read-directory f)" "(map #(.getName %) (.listFiles f))" "(.listFiles f)" "(file-seq f)" "f" "(fileseq f)" "(ds/read-directory f)" "(ds/read-directories [] f)" "(ds/read-directories [\"A\" \"B\"] f)" "(def f  (io/file \"resources/data/app1-prd\"))" "(ds/read-directories [\"A\" \"B\"] f)" "(require '[sisyphus.data-store :as ds])" "(reset)" "(.getCanonicalPath f)" "(.getCanonicalName f)" "(.getCanonicalFile f)" "(.getCanonicalName f)" "(.getName f)" "f" "(def f  (io/file \"resources/data/app1-prd\"))" "(io/file \"resources/data/app1-prd\")" "(require '[clojure.java.io :as io])" "(java.io/file)" "(reset)" "(go)" "(reset)" "(restart)" "(reset)" "(go)" "(quit)" "(go)" "(stop)" "(reset)" "(go)" "(reset)" "(require '[schema.core :as s])" "(use 'sisyphus.endpoint.config)" "(use 'sisyphus.config.endpoint)" "(reset)" "(reser)" "(stop)" "(reset)" "(go)" "(reset)" "(go)" "(stop)" "(reset)" "(type (merge-schemas \"resources/schema\"))" "(reset)" "(merge-schemas \"resources/schema\")" "(require '[schema.core :as s])" "(merge-schemas \"resources/schema\")" "(use 'sisyphus.endpoint.example)" "(reset)" "foo" "(def foo (eval  (read-string (slurp (io/file \"resources/schema/default.clj\")))))" "foo" "(def foo (eval  (read-string (slurp (io/file \"resources/schema/default.clj\")))))" "(eval  (read-string (slurp (io/file \"resources/schema/default.clj\"))))" "(read-string (slurp (io/file \"resources/schema/default.clj\")))" "(slurp (io/file \"resources/schema/default.clj\"))" "(slurp (io/file \"resources/schema/default2.clj\"))" "(.getName (io/file \"resources/schema/default2.clj\"))" "(.getName (io/file \"resources/schema/default1.clj\"))" "(.getName (io/file \"resources/schema/default.clj\"))" "(io/file \"resources/schema/default.clj\")" "(load-schema \"resources/schema/default.clj\")" "(load-schema1 \"resources/schema/default.clj\")" "(use 'sisyphus.endpoint.example)" "(load-schema1 \"resources/schema/default.clj\")" "(load-schema \"resources/schema/default.clj\")" "(require 'sisyphus.endpoint.example)" "(load-schema \"resources/schema/default.clj\")" "(require 'sisyphus.endpoint.example)" "(load-schema \"resources/schema/default.clj\")" "(go)" "(reset)" "(go)" "(def s1 (-> \"resources/schema/default.clj\" slurp read-string eval))" "(s/validate s1 {:k1 \"sdd\"})" "(s/validate s1 {\"dd\" \"sdd\"})" "(def s1 (-> \"resources/schema/default.clj\" slurp read-string eval))" "(-> \"resources/schema/default.clj\" slurp read-string eval)" "(-> \"resources/schema/default.clj\" slurp)" "(load-schema \"resources/schemas/default.clj\")" "(require 'sisyphus.endpoint.example)" "(load-schema \"resources/schemas/default.clj\")" "(require 'sisyphus.endpoint.example)" "(load-schema \"resources/schemas/default.clj\")" "(s/validate schema3 {:foo \"1234\"})" "(def schema3 (eval (read-string \"{schema.core/Any schema.core/Any}\")))" "(s/validate schema3 {:foo \"1234\"})" "(def schema3 (read-string \"{schema.core/Any schema.core/Any}\"))" "(s/validate schema3 {:foo \"1234\"})" "(def schema3 (read-string \"{s/Any s/Any}\"))" "(= schema1 schema2)" "(type schema2)" "(s/validate schema2 {:foo \"1234\"})" "schema2" "(def schema2 (edn/read-string \"{s/Any s/Any}\"))" "(s/validate schema1 {:foo \"1234\"})" "(def schema1 {s/Any s/Any})" "(s/validate {s/Any s/Any} {:foo \"1234\"})" "(s/validate schema {:foo \"1234\"})" "schema" "(s/validate schema {:foo \"1234\"})" "schema" "(s/validate schema {:foo 1234})" "(def schema (edn/read-string \"{s/Any s/Any}\"))" "(edn/read-string \"{s/Any s/Any}\")" "(edn/read-string \"{so/Any so/Any}\")" "(edn/read-string \"{s/Any s/Any}\")" "(require '[clojure.edn :as edn])" "(s/validate {s/Any s/Any} [ 1 2 3])" "(s/validate {s/Any s/Any} {:test \"foo\"})" "(require '[schema.core :as s])" "(s/validate {s/Any s/Any} {:test \"foo\"})" "(reset)" "(sishypus.schema.config/Config)" "Config" "(load-file \"resources/schema/default.clj\")" "Config" "(merge-schemas schema-data-path)" "(use 'sisyphus.endpoint.example)" "(merge-schemas schema-data-path)" "(use 'sisyphus.endpoint.example)" "(go)" "(reset)" "(go)" "(stop)" "(reset)" "(go)" "(read-directory \"resources/data/A/B\")" "(read-directory \"resources/data/A\")" "(load-config \"A/B/C\")" "(load-config \"A/D/C\")" "(load-config \"A/B/D\")" "(load-config \"A/B/C\")" "(use 'sisyphus.endpoint.example)" "(load-config \"A/B/C\")" "(load-config \"A/B\")" "(use 'sisyphus.endpoint.example)" "(load-config \"A/B\")" "(use 'sisyphus.endpoint.example)" "(build-paths dirs)" "(def dirs(clojure.string/split \"ICC/PEAK/EU/ES\" #\"/\"))" "dirs" "(build-paths dirs)" "(use 'sisyphus.endpoint.example)" "(read-directories \"/Users/icabrebarrera/dev/clojure/sisyphus/resources/data\")" "(use 'sisyphus.endpoint.example)" "(clojure.string/join \"/\" (take 2 dirs))" "(join \"/\" (take 2 dirs))" "(join (take 2 dirs) /)" "(clojure.string/join (take 2 dirs) /)" "(clojure.string/join / (take 2 dirs))" "(take 2 dirs)" "dirs" "(for [i (range 1 (count dirs))] (clojure.string/join (take i dirs) \"/\"))" "(for [i (range 1 (count dirs))] (println (clojure.string/join (take dirs i) \"/\")))" "(for [i (range 1 (count dirs))] (println (clojure.string/join (take i dirs) \"/\")))" "dirs" "(def dirs(clojure.string/split \"ICC/PEAK/EU/ES\" #\"/\"))" "(clojure.string/split \"ICC/PEAK/EU/ES\" #\"/\")" "(clojure.string/split \"ICC/PEAK/EU/ES\")" "(clojure.string/split \"test/dadfadf/\" #\"/\")" "(clojure.string/split \"test\" #\"/\")" "(clojure.string/split \"test\" \"/\")" "(split \"/a/a\" \"/\")" "(load-files \"resources/data\" #(.getName %))" "(load-files \".\" #(.getName %))" "(load-files \".e\" #(.getName %))" "(load-files . #(.getName %))" "(use 'sisyphus.endpoint.example)" "(clojure.edn/read-string \"false\")" "(use 'clojure.edn)" "(clojure.edn/read-string \"false\")" "(pr-str \"dfsd\")" "(.exists (clojure.java.io/as-file \"/tmp/a.txt\"))" "(.exists (clojure.java.io/as-file \"jkk\"))" "(clojure.java.io/as-file \"jkk\")" "(rand 100)" "(doc rand)" "(.start server)" "(.stop server)" "(.start server)" "(.stop server)" "(sieve' 2)" "(sieve 2)" "(in-ns 'eratosthenes.core)" "(+)" "(cons 1 [2 3])" "(conj [1 2] 3)" "(conj '(1 2) 3)" "(doc conj)" "(doc repeatedly)" "(doc repeat)" "(first [1 2 3])" "(head [1 2 2])" "(cond (== 2 2) (print \"tret\"))" "(cond (== 1 2) (print \"tret\"))" "(cond [(== 1 2) (print \"test\")])" "(cond)" ") (cond (==1 2) (print \"test\"))" "(cond [(== 1 2) (print \"test\") (print \"no tets\")])" "(doc cond)" "(mod 3 2)" "(% 3 2)" "(range 2 4)" "(range 10)")